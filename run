#!/bin/bash

set -e

COMMAND=${1:-start}
shift || true

case "$COMMAND" in
  start)
    echo "[START] Starting Goud Chain network (production mode)..."
    echo ""
    echo "[CONFIG] Generating latest configs from templates..."
    ./config/scripts/generate-configs.sh local
    echo ""
    echo "[API] LOAD BALANCER (Primary API): http://localhost:8080"
    echo "   â””â”€ Use this endpoint for all blockchain operations"
    echo ""
    echo "[WEB] Dashboard: http://localhost:3000"
    echo ""
    echo "[DEBUG] Individual Nodes (for debugging):"
    echo "   Node 1: http://localhost:8081"
    echo "   Node 2: http://localhost:8082"
    echo "   Node 3: http://localhost:8083"
    echo ""
    docker compose -f docker-compose.local.yml up --build
    ;;

  dev)
    BUILD_MODE="release"
    if [[ "$1" == "--fast-build" ]]; then
      BUILD_MODE="debug"
      shift
    fi

    echo "[DEV] Starting Goud Chain network (hot reload, ${BUILD_MODE} mode)..."
    ./config/scripts/generate-configs.sh local
    echo ""
    echo "[API] http://localhost:8080 (Load Balancer)"
    echo "[WEB] http://localhost:3001 (Dashboard with hot reload)"
    echo "[JUPYTER] http://localhost:8888"
    echo ""
    echo "[NODES] http://localhost:8081, 8082, 8083"
    echo ""
    if [[ "$BUILD_MODE" == "debug" ]]; then
      echo "[BUILD] Debug mode: Fast rebuilds (~5-10s), slow runtime (~4-10s blocks)"
    else
      echo "[BUILD] Release mode: Slow rebuilds (~30-60s), fast runtime (~20-50ms blocks)"
      echo "        Add --fast-build flag for debug mode"
    fi
    echo ""
    BUILD_MODE=$BUILD_MODE docker compose -f docker-compose.local.yml -f docker-compose.local.dev.yml up --build
    ;;

  build)
    echo "[BUILD] Building Docker images..."
    docker compose -f docker-compose.local.yml build
    ;;

  down|stop)
    echo "[STOP] Stopping Goud Chain network..."
    docker compose -f docker-compose.local.yml -f docker-compose.local.dev.yml down 2>/dev/null || docker compose -f docker-compose.local.yml down
    ;;

  clean)
    echo "[CLEAN] Cleaning up containers, images, and volumes..."
    docker compose -f docker-compose.local.yml down --rmi all --volumes --remove-orphans
    ;;

  prune)
    echo "[PRUNE] Docker space reclamation utility"
    echo "========================================"
    echo ""
    docker system df
    echo ""
    echo "Available operations:"
    echo "  1) Remove all unused images (dangling + unreferenced)"
    echo "  2) Remove build cache only"
    echo "  3) Remove unused volumes"
    echo "  4) Nuclear option: prune everything (containers + images + cache + volumes)"
    echo "  5) Show what would be deleted (dry run)"
    echo ""
    read -p "Select option [1-5]: " choice
    case $choice in
      1)
        echo "[PRUNE] Removing unused images..."
        docker image prune -a -f
        ;;
      2)
        echo "[PRUNE] Removing build cache..."
        docker builder prune -a -f
        ;;
      3)
        echo "[PRUNE] Removing unused volumes..."
        docker volume prune -f
        ;;
      4)
        echo "[WARN] This will remove ALL stopped containers, unused images, build cache, and volumes"
        read -p "Are you sure? [y/N]: " confirm
        if [[ "$confirm" =~ ^[Yy]$ ]]; then
          echo "[PRUNE] Removing everything..."
          docker system prune -a --volumes -f
        else
          echo "[PRUNE] Cancelled"
        fi
        ;;
      5)
        echo "[PRUNE] Dry run (showing what would be deleted):"
        echo ""
        echo "Unused images:"
        docker image prune -a --filter "until=24h" --format "{{.ID}}: {{.Size}}" || echo "  None"
        echo ""
        echo "Build cache:"
        docker builder du
        echo ""
        echo "Unused volumes:"
        docker volume ls -qf dangling=true || echo "  None"
        ;;
      *)
        echo "[ERR] Invalid option"
        exit 1
        ;;
    esac
    echo ""
    echo "[PRUNE] After cleanup:"
    docker system df
    ;;

  logs)
    NODE=${1:-}
    if [ -z "$NODE" ]; then
      echo "[CONFIG] Showing logs from all nodes..."
      docker compose -f docker-compose.local.yml logs -f
    else
      echo "[CONFIG] Showing logs from $NODE..."
      docker compose -f docker-compose.local.yml logs -f "$NODE"
    fi
    ;;

  status)
    echo "[STATUS] Network Status"
    echo "================="
    echo ""

    # Check load balancer
    echo "[API] Load Balancer (http://localhost:8080)"
    if curl -s "http://localhost:8080/lb/health" > /dev/null 2>&1; then
      LB_INFO=$(curl -s "http://localhost:8080/lb/health")
      echo "   [OK] Online"
      echo "   $(echo $LB_INFO | jq -r '.service')"
    else
      echo "   [ERR] Offline"
    fi
    echo ""

    # Check individual nodes
    for node in node1 node2 node3; do
      port=$((8080 + ${node:4}))
      echo "[NODE] $node (http://localhost:$port)"

      if curl -s "http://localhost:$port/health" > /dev/null 2>&1; then
        HEALTH=$(curl -s "http://localhost:$port/health")
        CHAIN_LENGTH=$(echo $HEALTH | jq -r '.chain_length')
        PEERS=$(echo $HEALTH | jq -r '.peer_count')
        NODE_ID=$(echo $HEALTH | jq -r '.node_id')
        echo "   [OK] Online | Chain Length: $CHAIN_LENGTH | Peers: $PEERS | ID: $NODE_ID"
      else
        echo "   [ERR] Offline"
      fi
      echo ""
    done
    ;;

  lb-status)
    echo "[API] Load Balancer Status"
    echo "======================"
    echo ""

    if curl -s "http://localhost:8080/lb/health" > /dev/null 2>&1; then
      echo "Health:"
      curl -s "http://localhost:8080/lb/health" | jq .
      echo ""
      echo "NGINX Stats:"
      curl -s "http://localhost:8080/lb/status"
    else
      echo "[ERR] Load balancer is offline"
      exit 1
    fi
    ;;

  mine)
    NODE=${1:-node1}
    DATA=${2:-"Transaction data"}

    PORT=8081
    case "$NODE" in
      node1) PORT=8081 ;;
      node2) PORT=8082 ;;
      node3) PORT=8083 ;;
      *) echo "[ERR] Invalid node. Use: node1, node2, or node3"; exit 1 ;;
    esac

    echo "Mining block on $NODE with data: \"$DATA\""
    curl -X POST "http://localhost:$PORT/mine" \
      -H "Content-Type: application/json" \
      -d "{\"data\": \"$DATA\"}" | jq .
    ;;

  chain)
    NODE=${1:-node1}

    PORT=8081
    case "$NODE" in
      node1) PORT=8081 ;;
      node2) PORT=8082 ;;
      node3) PORT=8083 ;;
      *) echo "[ERR] Invalid node. Use: node1, node2, or node3"; exit 1 ;;
    esac

    echo "Blockchain from $NODE:"
    curl -s "http://localhost:$PORT/chain" | jq .
    ;;

  sync)
    NODE=${1:-node1}

    PORT=8081
    case "$NODE" in
      node1) PORT=8081 ;;
      node2) PORT=8082 ;;
      node3) PORT=8083 ;;
      *) echo "[ERR] Invalid node. Use: node1, node2, or node3"; exit 1 ;;
    esac

    echo "Syncing $NODE with peers..."
    curl -s "http://localhost:$PORT/sync" | jq .
    ;;

  peers)
    NODE=${1:-node1}

    PORT=8081
    case "$NODE" in
      node1) PORT=8081 ;;
      node2) PORT=8082 ;;
      node3) PORT=8083 ;;
      *) echo "[ERR] Invalid node. Use: node1, node2, or node3"; exit 1 ;;
    esac

    echo "Peers of $NODE:"
    curl -s "http://localhost:$PORT/peers" | jq .
    ;;

  test)
    echo "ðŸ§ª Running tests..."
    cargo test
    ;;

  run)
    echo "Running single node locally (without Docker)..."
    cargo run
    ;;

  check)
    echo "Checking code..."
    cargo check
    ;;

  fmt)
    echo "[FMT] Formatting code..."
    cargo fmt
    ;;

  demo)
    echo "[DEMO] Running demo scenario..."
    echo ""

    echo "[1/4] Mining block on node1..."
    curl -X POST "http://localhost:8081/mine" \
      -H "Content-Type: application/json" \
      -d '{"data": "Alice sends 10 coins to Bob"}' 2>/dev/null | jq .

    echo ""
    echo "[2/4] Waiting for propagation..."
    sleep 2

    echo ""
    echo "[3/4] Mining block on node2..."
    curl -X POST "http://localhost:8082/mine" \
      -H "Content-Type: application/json" \
      -d '{"data": "Bob sends 5 coins to Charlie"}' 2>/dev/null | jq .

    echo ""
    echo "[4/4] Checking all node chains..."
    sleep 2

    for node in node1 node2 node3; do
      port=$((8080 + ${node:4}))
      echo ""
      echo "$node chain length:"
      curl -s "http://localhost:$port/chain" | jq '.chain | length'
    done
    ;;

  volumes-list)
    echo "[VOLUMES] Listing Docker volumes..."
    docker volume ls | grep "goud\|node.*_data\|jupyter"
    ;;

  volumes-inspect)
    NODE=${1:-node1}
    VOLUME="${NODE}_data"
    echo "[VOLUMES] Inspecting volume: $VOLUME"
    docker volume inspect "$VOLUME" || {
      echo "[ERR] Volume not found: $VOLUME"
      exit 1
    }
    ;;

  volumes-check)
    echo "[VOLUMES] Volume Health Check"
    echo "============================="
    echo ""
    
    # Check for volumes
    VOLUMES=$(docker volume ls -q | grep "node.*_data" || true)
    
    if [ -z "$VOLUMES" ]; then
      echo "[WARN] No data volumes found (network may not be started)"
      exit 0
    fi
    
    for volume in $VOLUMES; do
      echo "[CHECK] Volume: $volume"
      
      # Get volume info
      SIZE=$(docker run --rm -v "$volume:/data:ro" alpine du -sh /data 2>/dev/null | cut -f1 || echo "unknown")
      MOUNT=$(docker volume inspect "$volume" --format '{{.Mountpoint}}' 2>/dev/null || echo "unknown")
      
      echo "  Size: $SIZE"
      echo "  Mountpoint: $MOUNT"
      
      # Check if RocksDB directory exists
      HAS_ROCKSDB=$(docker run --rm -v "$volume:/data:ro" alpine test -d /data/rocksdb && echo "yes" || echo "no")
      if [ "$HAS_ROCKSDB" = "yes" ]; then
        BLOCK_COUNT=$(docker run --rm -v "$volume:/data:ro" alpine find /data/rocksdb -name "*.sst" 2>/dev/null | wc -l || echo "0")
        echo "  RocksDB: Present ($BLOCK_COUNT SST files)"
      else
        echo "  RocksDB: Not initialized"
      fi
      echo ""
    done
    ;;

  backup)
    ENV=${1:-local}
    echo "[BACKUP] Creating volume backup for environment: $ENV"
    ./scripts/backup-volumes.sh --environment "$ENV" "$@"
    ;;

  restore)
    if [ -z "$1" ]; then
      echo "[ERR] Backup file required"
      echo "Usage: ./run restore <backup-file>"
      exit 1
    fi
    echo "[RESTORE] Restoring volumes from backup: $1"
    ./scripts/restore-volumes.sh --backup "$1"
    ;;

  help|--help|-h)
    echo "Goud Chain - Distributed Blockchain Network"
    echo ""
    echo "Usage: ./run [command] [args]"
    echo ""
    echo "Network Commands:"
    echo "  start                    Production mode (release builds)"
    echo "  dev                      Hot reload (release builds, slow rebuilds, fast runtime)"
    echo "  dev --fast-build         Hot reload (debug builds, fast rebuilds, slow runtime)"
    echo "  build                    Build Docker images"
    echo "  down, stop               Stop network"
    echo "  clean                    Remove containers, images, volumes"
    echo "  prune                    Interactive Docker cleanup"
    echo "  logs [node]              Show logs (node1, node2, node3, nginx)"
    echo "  status                   Load balancer + node status"
    echo "  lb-status                Detailed load balancer metrics"
    echo ""
    echo "Volume Management:"
    echo "  volumes-list             List data volumes"
    echo "  volumes-inspect [node]   Inspect volume (default: node1)"
    echo "  volumes-check            Volume health check"
    echo "  backup [env]             Create backup (default: local)"
    echo "  restore <file>           Restore from backup"
    echo ""
    echo "Blockchain Commands:"
    echo "  mine [node] [data]       Mine block (default: node1)"
    echo "  chain [node]             View chain (default: node1)"
    echo "  sync [node]              Sync with peers (default: node1)"
    echo "  peers [node]             View peers (default: node1)"
    echo ""
    echo "Development Commands:"
    echo "  test                     Run cargo tests"
    echo "  run                      Run single node locally"
    echo "  check                    Check code with cargo"
    echo "  fmt                      Format code"
    echo ""
    echo "Demo:"
    echo "  demo                     Run demo scenario"
    echo ""
    echo "Endpoints:"
    echo "  [API] http://localhost:8080 (Load Balancer)"
    echo "  [WEB] http://localhost:3000 (Dashboard)"
    echo "  [JUPYTER] http://localhost:8888 (dev mode only)"
    echo "  [NODES] http://localhost:8081, 8082, 8083"
    ;;

  *)
    echo "[ERR] Unknown command: $COMMAND"
    echo "Run './run help' for available commands"
    exit 1
    ;;
esac
